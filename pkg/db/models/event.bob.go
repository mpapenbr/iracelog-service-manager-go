// Code generated by BobGen psql v0.42.0. DO NOT EDIT.
// This file is meant to be re-generated in place and/or deleted at any time.

package models

import (
	"context"
	"fmt"
	"io"
	"time"

	"github.com/aarondl/opt/null"
	"github.com/aarondl/opt/omit"
	"github.com/aarondl/opt/omitnull"
	mytypes "github.com/mpapenbr/iracelog-service-manager-go/pkg/db/mytypes"
	"github.com/shopspring/decimal"
	"github.com/stephenafamo/bob"
	"github.com/stephenafamo/bob/dialect/psql"
	"github.com/stephenafamo/bob/dialect/psql/dialect"
	"github.com/stephenafamo/bob/dialect/psql/dm"
	"github.com/stephenafamo/bob/dialect/psql/sm"
	"github.com/stephenafamo/bob/dialect/psql/um"
	"github.com/stephenafamo/bob/expr"
	"github.com/stephenafamo/bob/mods"
	"github.com/stephenafamo/bob/orm"
	"github.com/stephenafamo/bob/types/pgtypes"
)

// Event is an object representing the database table.
type Event struct {
	ID                int32            `db:"id,pk" `
	EventKey          string           `db:"event_key" `
	Name              string           `db:"name" `
	Description       null.Val[string] `db:"description" `
	EventTime         time.Time        `db:"event_time" `
	RaceloggerVersion string           `db:"racelogger_version" `
	TeamRacing        bool             `db:"team_racing" `
	MultiClass        bool             `db:"multi_class" `
	NumCarTypes       int32            `db:"num_car_types" `
	NumCarClasses     int32            `db:"num_car_classes" `
	IrSessionID       null.Val[int32]  `db:"ir_session_id" `
	TrackID           int32            `db:"track_id" `
	PitSpeed          decimal.Decimal  `db:"pit_speed" `
	// timestamp of the race start
	ReplayMinTimestamp time.Time `db:"replay_min_timestamp" `
	// session time of the race start
	ReplayMinSessionTime decimal.Decimal `db:"replay_min_session_time" `
	// session time of the race end
	ReplayMaxSessionTime decimal.Decimal                 `db:"replay_max_session_time" `
	Sessions             mytypes.EventSessionSlice       `db:"sessions" `
	IrSubSessionID       int32                           `db:"ir_sub_session_id" `
	TenantID             int32                           `db:"tenant_id" `
	TireInfos            null.Val[mytypes.TireInfoSlice] `db:"tire_infos" `

	R eventR `db:"-" `
}

// EventSlice is an alias for a slice of pointers to Event.
// This should almost always be used instead of []*Event.
type EventSlice []*Event

// Events contains methods to work with the event table
var Events = psql.NewTablex[*Event, EventSlice, *EventSetter]("", "event", buildEventColumns("event"))

// EventsQuery is a query on the event table
type EventsQuery = *psql.ViewQuery[*Event, EventSlice]

// eventR is where relationships are stored.
type eventR struct {
	AnalysisProto *AnalysisProto // analysis_proto.analysis_proto_event_id_fkey
	CCars         CCarSlice      // c_car.c_car_event_id_fkey
	CCarClasses   CCarClassSlice // c_car_class.c_car_class_event_id_fkey
	CCarEntries   CCarEntrySlice // c_car_entry.c_car_entry_event_id_fkey
	Tenant        *Tenant        // event.event_tenant_id_fk
	Track         *Track         // event.event_track_id_fkey
	EventExt      *EventExt      // event_ext.event_ext_event_id_fkey
	RSInfos       RSInfoSlice    // rs_info.rs_info_event_id_fkey
}

func buildEventColumns(alias string) eventColumns {
	return eventColumns{
		ColumnsExpr: expr.NewColumnsExpr(
			"id", "event_key", "name", "description", "event_time", "racelogger_version", "team_racing", "multi_class", "num_car_types", "num_car_classes", "ir_session_id", "track_id", "pit_speed", "replay_min_timestamp", "replay_min_session_time", "replay_max_session_time", "sessions", "ir_sub_session_id", "tenant_id", "tire_infos",
		).WithParent("event"),
		tableAlias:           alias,
		ID:                   psql.Quote(alias, "id"),
		EventKey:             psql.Quote(alias, "event_key"),
		Name:                 psql.Quote(alias, "name"),
		Description:          psql.Quote(alias, "description"),
		EventTime:            psql.Quote(alias, "event_time"),
		RaceloggerVersion:    psql.Quote(alias, "racelogger_version"),
		TeamRacing:           psql.Quote(alias, "team_racing"),
		MultiClass:           psql.Quote(alias, "multi_class"),
		NumCarTypes:          psql.Quote(alias, "num_car_types"),
		NumCarClasses:        psql.Quote(alias, "num_car_classes"),
		IrSessionID:          psql.Quote(alias, "ir_session_id"),
		TrackID:              psql.Quote(alias, "track_id"),
		PitSpeed:             psql.Quote(alias, "pit_speed"),
		ReplayMinTimestamp:   psql.Quote(alias, "replay_min_timestamp"),
		ReplayMinSessionTime: psql.Quote(alias, "replay_min_session_time"),
		ReplayMaxSessionTime: psql.Quote(alias, "replay_max_session_time"),
		Sessions:             psql.Quote(alias, "sessions"),
		IrSubSessionID:       psql.Quote(alias, "ir_sub_session_id"),
		TenantID:             psql.Quote(alias, "tenant_id"),
		TireInfos:            psql.Quote(alias, "tire_infos"),
	}
}

type eventColumns struct {
	expr.ColumnsExpr
	tableAlias           string
	ID                   psql.Expression
	EventKey             psql.Expression
	Name                 psql.Expression
	Description          psql.Expression
	EventTime            psql.Expression
	RaceloggerVersion    psql.Expression
	TeamRacing           psql.Expression
	MultiClass           psql.Expression
	NumCarTypes          psql.Expression
	NumCarClasses        psql.Expression
	IrSessionID          psql.Expression
	TrackID              psql.Expression
	PitSpeed             psql.Expression
	ReplayMinTimestamp   psql.Expression
	ReplayMinSessionTime psql.Expression
	ReplayMaxSessionTime psql.Expression
	Sessions             psql.Expression
	IrSubSessionID       psql.Expression
	TenantID             psql.Expression
	TireInfos            psql.Expression
}

func (c eventColumns) Alias() string {
	return c.tableAlias
}

func (eventColumns) AliasedAs(alias string) eventColumns {
	return buildEventColumns(alias)
}

// EventSetter is used for insert/upsert/update operations
// All values are optional, and do not have to be set
// Generated columns are not included
type EventSetter struct {
	ID                   omit.Val[int32]                     `db:"id,pk" `
	EventKey             omit.Val[string]                    `db:"event_key" `
	Name                 omit.Val[string]                    `db:"name" `
	Description          omitnull.Val[string]                `db:"description" `
	EventTime            omit.Val[time.Time]                 `db:"event_time" `
	RaceloggerVersion    omit.Val[string]                    `db:"racelogger_version" `
	TeamRacing           omit.Val[bool]                      `db:"team_racing" `
	MultiClass           omit.Val[bool]                      `db:"multi_class" `
	NumCarTypes          omit.Val[int32]                     `db:"num_car_types" `
	NumCarClasses        omit.Val[int32]                     `db:"num_car_classes" `
	IrSessionID          omitnull.Val[int32]                 `db:"ir_session_id" `
	TrackID              omit.Val[int32]                     `db:"track_id" `
	PitSpeed             omit.Val[decimal.Decimal]           `db:"pit_speed" `
	ReplayMinTimestamp   omit.Val[time.Time]                 `db:"replay_min_timestamp" `
	ReplayMinSessionTime omit.Val[decimal.Decimal]           `db:"replay_min_session_time" `
	ReplayMaxSessionTime omit.Val[decimal.Decimal]           `db:"replay_max_session_time" `
	Sessions             omit.Val[mytypes.EventSessionSlice] `db:"sessions" `
	IrSubSessionID       omit.Val[int32]                     `db:"ir_sub_session_id" `
	TenantID             omit.Val[int32]                     `db:"tenant_id" `
	TireInfos            omitnull.Val[mytypes.TireInfoSlice] `db:"tire_infos" `
}

func (s EventSetter) SetColumns() []string {
	vals := make([]string, 0, 20)
	if s.ID.IsValue() {
		vals = append(vals, "id")
	}
	if s.EventKey.IsValue() {
		vals = append(vals, "event_key")
	}
	if s.Name.IsValue() {
		vals = append(vals, "name")
	}
	if !s.Description.IsUnset() {
		vals = append(vals, "description")
	}
	if s.EventTime.IsValue() {
		vals = append(vals, "event_time")
	}
	if s.RaceloggerVersion.IsValue() {
		vals = append(vals, "racelogger_version")
	}
	if s.TeamRacing.IsValue() {
		vals = append(vals, "team_racing")
	}
	if s.MultiClass.IsValue() {
		vals = append(vals, "multi_class")
	}
	if s.NumCarTypes.IsValue() {
		vals = append(vals, "num_car_types")
	}
	if s.NumCarClasses.IsValue() {
		vals = append(vals, "num_car_classes")
	}
	if !s.IrSessionID.IsUnset() {
		vals = append(vals, "ir_session_id")
	}
	if s.TrackID.IsValue() {
		vals = append(vals, "track_id")
	}
	if s.PitSpeed.IsValue() {
		vals = append(vals, "pit_speed")
	}
	if s.ReplayMinTimestamp.IsValue() {
		vals = append(vals, "replay_min_timestamp")
	}
	if s.ReplayMinSessionTime.IsValue() {
		vals = append(vals, "replay_min_session_time")
	}
	if s.ReplayMaxSessionTime.IsValue() {
		vals = append(vals, "replay_max_session_time")
	}
	if s.Sessions.IsValue() {
		vals = append(vals, "sessions")
	}
	if s.IrSubSessionID.IsValue() {
		vals = append(vals, "ir_sub_session_id")
	}
	if s.TenantID.IsValue() {
		vals = append(vals, "tenant_id")
	}
	if !s.TireInfos.IsUnset() {
		vals = append(vals, "tire_infos")
	}
	return vals
}

func (s EventSetter) Overwrite(t *Event) {
	if s.ID.IsValue() {
		t.ID = s.ID.MustGet()
	}
	if s.EventKey.IsValue() {
		t.EventKey = s.EventKey.MustGet()
	}
	if s.Name.IsValue() {
		t.Name = s.Name.MustGet()
	}
	if !s.Description.IsUnset() {
		t.Description = s.Description.MustGetNull()
	}
	if s.EventTime.IsValue() {
		t.EventTime = s.EventTime.MustGet()
	}
	if s.RaceloggerVersion.IsValue() {
		t.RaceloggerVersion = s.RaceloggerVersion.MustGet()
	}
	if s.TeamRacing.IsValue() {
		t.TeamRacing = s.TeamRacing.MustGet()
	}
	if s.MultiClass.IsValue() {
		t.MultiClass = s.MultiClass.MustGet()
	}
	if s.NumCarTypes.IsValue() {
		t.NumCarTypes = s.NumCarTypes.MustGet()
	}
	if s.NumCarClasses.IsValue() {
		t.NumCarClasses = s.NumCarClasses.MustGet()
	}
	if !s.IrSessionID.IsUnset() {
		t.IrSessionID = s.IrSessionID.MustGetNull()
	}
	if s.TrackID.IsValue() {
		t.TrackID = s.TrackID.MustGet()
	}
	if s.PitSpeed.IsValue() {
		t.PitSpeed = s.PitSpeed.MustGet()
	}
	if s.ReplayMinTimestamp.IsValue() {
		t.ReplayMinTimestamp = s.ReplayMinTimestamp.MustGet()
	}
	if s.ReplayMinSessionTime.IsValue() {
		t.ReplayMinSessionTime = s.ReplayMinSessionTime.MustGet()
	}
	if s.ReplayMaxSessionTime.IsValue() {
		t.ReplayMaxSessionTime = s.ReplayMaxSessionTime.MustGet()
	}
	if s.Sessions.IsValue() {
		t.Sessions = s.Sessions.MustGet()
	}
	if s.IrSubSessionID.IsValue() {
		t.IrSubSessionID = s.IrSubSessionID.MustGet()
	}
	if s.TenantID.IsValue() {
		t.TenantID = s.TenantID.MustGet()
	}
	if !s.TireInfos.IsUnset() {
		t.TireInfos = s.TireInfos.MustGetNull()
	}
}

func (s *EventSetter) Apply(q *dialect.InsertQuery) {
	q.AppendHooks(func(ctx context.Context, exec bob.Executor) (context.Context, error) {
		return Events.BeforeInsertHooks.RunHooks(ctx, exec, s)
	})

	q.AppendValues(bob.ExpressionFunc(func(ctx context.Context, w io.StringWriter, d bob.Dialect, start int) ([]any, error) {
		vals := make([]bob.Expression, 20)
		if s.ID.IsValue() {
			vals[0] = psql.Arg(s.ID.MustGet())
		} else {
			vals[0] = psql.Raw("DEFAULT")
		}

		if s.EventKey.IsValue() {
			vals[1] = psql.Arg(s.EventKey.MustGet())
		} else {
			vals[1] = psql.Raw("DEFAULT")
		}

		if s.Name.IsValue() {
			vals[2] = psql.Arg(s.Name.MustGet())
		} else {
			vals[2] = psql.Raw("DEFAULT")
		}

		if !s.Description.IsUnset() {
			vals[3] = psql.Arg(s.Description.MustGetNull())
		} else {
			vals[3] = psql.Raw("DEFAULT")
		}

		if s.EventTime.IsValue() {
			vals[4] = psql.Arg(s.EventTime.MustGet())
		} else {
			vals[4] = psql.Raw("DEFAULT")
		}

		if s.RaceloggerVersion.IsValue() {
			vals[5] = psql.Arg(s.RaceloggerVersion.MustGet())
		} else {
			vals[5] = psql.Raw("DEFAULT")
		}

		if s.TeamRacing.IsValue() {
			vals[6] = psql.Arg(s.TeamRacing.MustGet())
		} else {
			vals[6] = psql.Raw("DEFAULT")
		}

		if s.MultiClass.IsValue() {
			vals[7] = psql.Arg(s.MultiClass.MustGet())
		} else {
			vals[7] = psql.Raw("DEFAULT")
		}

		if s.NumCarTypes.IsValue() {
			vals[8] = psql.Arg(s.NumCarTypes.MustGet())
		} else {
			vals[8] = psql.Raw("DEFAULT")
		}

		if s.NumCarClasses.IsValue() {
			vals[9] = psql.Arg(s.NumCarClasses.MustGet())
		} else {
			vals[9] = psql.Raw("DEFAULT")
		}

		if !s.IrSessionID.IsUnset() {
			vals[10] = psql.Arg(s.IrSessionID.MustGetNull())
		} else {
			vals[10] = psql.Raw("DEFAULT")
		}

		if s.TrackID.IsValue() {
			vals[11] = psql.Arg(s.TrackID.MustGet())
		} else {
			vals[11] = psql.Raw("DEFAULT")
		}

		if s.PitSpeed.IsValue() {
			vals[12] = psql.Arg(s.PitSpeed.MustGet())
		} else {
			vals[12] = psql.Raw("DEFAULT")
		}

		if s.ReplayMinTimestamp.IsValue() {
			vals[13] = psql.Arg(s.ReplayMinTimestamp.MustGet())
		} else {
			vals[13] = psql.Raw("DEFAULT")
		}

		if s.ReplayMinSessionTime.IsValue() {
			vals[14] = psql.Arg(s.ReplayMinSessionTime.MustGet())
		} else {
			vals[14] = psql.Raw("DEFAULT")
		}

		if s.ReplayMaxSessionTime.IsValue() {
			vals[15] = psql.Arg(s.ReplayMaxSessionTime.MustGet())
		} else {
			vals[15] = psql.Raw("DEFAULT")
		}

		if s.Sessions.IsValue() {
			vals[16] = psql.Arg(s.Sessions.MustGet())
		} else {
			vals[16] = psql.Raw("DEFAULT")
		}

		if s.IrSubSessionID.IsValue() {
			vals[17] = psql.Arg(s.IrSubSessionID.MustGet())
		} else {
			vals[17] = psql.Raw("DEFAULT")
		}

		if s.TenantID.IsValue() {
			vals[18] = psql.Arg(s.TenantID.MustGet())
		} else {
			vals[18] = psql.Raw("DEFAULT")
		}

		if !s.TireInfos.IsUnset() {
			vals[19] = psql.Arg(s.TireInfos.MustGetNull())
		} else {
			vals[19] = psql.Raw("DEFAULT")
		}

		return bob.ExpressSlice(ctx, w, d, start, vals, "", ", ", "")
	}))
}

func (s EventSetter) UpdateMod() bob.Mod[*dialect.UpdateQuery] {
	return um.Set(s.Expressions()...)
}

func (s EventSetter) Expressions(prefix ...string) []bob.Expression {
	exprs := make([]bob.Expression, 0, 20)

	if s.ID.IsValue() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "id")...),
			psql.Arg(s.ID),
		}})
	}

	if s.EventKey.IsValue() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "event_key")...),
			psql.Arg(s.EventKey),
		}})
	}

	if s.Name.IsValue() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "name")...),
			psql.Arg(s.Name),
		}})
	}

	if !s.Description.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "description")...),
			psql.Arg(s.Description),
		}})
	}

	if s.EventTime.IsValue() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "event_time")...),
			psql.Arg(s.EventTime),
		}})
	}

	if s.RaceloggerVersion.IsValue() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "racelogger_version")...),
			psql.Arg(s.RaceloggerVersion),
		}})
	}

	if s.TeamRacing.IsValue() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "team_racing")...),
			psql.Arg(s.TeamRacing),
		}})
	}

	if s.MultiClass.IsValue() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "multi_class")...),
			psql.Arg(s.MultiClass),
		}})
	}

	if s.NumCarTypes.IsValue() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "num_car_types")...),
			psql.Arg(s.NumCarTypes),
		}})
	}

	if s.NumCarClasses.IsValue() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "num_car_classes")...),
			psql.Arg(s.NumCarClasses),
		}})
	}

	if !s.IrSessionID.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "ir_session_id")...),
			psql.Arg(s.IrSessionID),
		}})
	}

	if s.TrackID.IsValue() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "track_id")...),
			psql.Arg(s.TrackID),
		}})
	}

	if s.PitSpeed.IsValue() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "pit_speed")...),
			psql.Arg(s.PitSpeed),
		}})
	}

	if s.ReplayMinTimestamp.IsValue() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "replay_min_timestamp")...),
			psql.Arg(s.ReplayMinTimestamp),
		}})
	}

	if s.ReplayMinSessionTime.IsValue() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "replay_min_session_time")...),
			psql.Arg(s.ReplayMinSessionTime),
		}})
	}

	if s.ReplayMaxSessionTime.IsValue() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "replay_max_session_time")...),
			psql.Arg(s.ReplayMaxSessionTime),
		}})
	}

	if s.Sessions.IsValue() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "sessions")...),
			psql.Arg(s.Sessions),
		}})
	}

	if s.IrSubSessionID.IsValue() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "ir_sub_session_id")...),
			psql.Arg(s.IrSubSessionID),
		}})
	}

	if s.TenantID.IsValue() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "tenant_id")...),
			psql.Arg(s.TenantID),
		}})
	}

	if !s.TireInfos.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "tire_infos")...),
			psql.Arg(s.TireInfos),
		}})
	}

	return exprs
}

// FindEvent retrieves a single record by primary key
// If cols is empty Find will return all columns.
func FindEvent(ctx context.Context, exec bob.Executor, IDPK int32, cols ...string) (*Event, error) {
	if len(cols) == 0 {
		return Events.Query(
			sm.Where(Events.Columns.ID.EQ(psql.Arg(IDPK))),
		).One(ctx, exec)
	}

	return Events.Query(
		sm.Where(Events.Columns.ID.EQ(psql.Arg(IDPK))),
		sm.Columns(Events.Columns.Only(cols...)),
	).One(ctx, exec)
}

// EventExists checks the presence of a single record by primary key
func EventExists(ctx context.Context, exec bob.Executor, IDPK int32) (bool, error) {
	return Events.Query(
		sm.Where(Events.Columns.ID.EQ(psql.Arg(IDPK))),
	).Exists(ctx, exec)
}

// AfterQueryHook is called after Event is retrieved from the database
func (o *Event) AfterQueryHook(ctx context.Context, exec bob.Executor, queryType bob.QueryType) error {
	var err error

	switch queryType {
	case bob.QueryTypeSelect:
		ctx, err = Events.AfterSelectHooks.RunHooks(ctx, exec, EventSlice{o})
	case bob.QueryTypeInsert:
		ctx, err = Events.AfterInsertHooks.RunHooks(ctx, exec, EventSlice{o})
	case bob.QueryTypeUpdate:
		ctx, err = Events.AfterUpdateHooks.RunHooks(ctx, exec, EventSlice{o})
	case bob.QueryTypeDelete:
		ctx, err = Events.AfterDeleteHooks.RunHooks(ctx, exec, EventSlice{o})
	}

	return err
}

// primaryKeyVals returns the primary key values of the Event
func (o *Event) primaryKeyVals() bob.Expression {
	return psql.Arg(o.ID)
}

func (o *Event) pkEQ() dialect.Expression {
	return psql.Quote("event", "id").EQ(bob.ExpressionFunc(func(ctx context.Context, w io.StringWriter, d bob.Dialect, start int) ([]any, error) {
		return o.primaryKeyVals().WriteSQL(ctx, w, d, start)
	}))
}

// Update uses an executor to update the Event
func (o *Event) Update(ctx context.Context, exec bob.Executor, s *EventSetter) error {
	v, err := Events.Update(s.UpdateMod(), um.Where(o.pkEQ())).One(ctx, exec)
	if err != nil {
		return err
	}

	o.R = v.R
	*o = *v

	return nil
}

// Delete deletes a single Event record with an executor
func (o *Event) Delete(ctx context.Context, exec bob.Executor) error {
	_, err := Events.Delete(dm.Where(o.pkEQ())).Exec(ctx, exec)
	return err
}

// Reload refreshes the Event using the executor
func (o *Event) Reload(ctx context.Context, exec bob.Executor) error {
	o2, err := Events.Query(
		sm.Where(Events.Columns.ID.EQ(psql.Arg(o.ID))),
	).One(ctx, exec)
	if err != nil {
		return err
	}
	o2.R = o.R
	*o = *o2

	return nil
}

// AfterQueryHook is called after EventSlice is retrieved from the database
func (o EventSlice) AfterQueryHook(ctx context.Context, exec bob.Executor, queryType bob.QueryType) error {
	var err error

	switch queryType {
	case bob.QueryTypeSelect:
		ctx, err = Events.AfterSelectHooks.RunHooks(ctx, exec, o)
	case bob.QueryTypeInsert:
		ctx, err = Events.AfterInsertHooks.RunHooks(ctx, exec, o)
	case bob.QueryTypeUpdate:
		ctx, err = Events.AfterUpdateHooks.RunHooks(ctx, exec, o)
	case bob.QueryTypeDelete:
		ctx, err = Events.AfterDeleteHooks.RunHooks(ctx, exec, o)
	}

	return err
}

func (o EventSlice) pkIN() dialect.Expression {
	if len(o) == 0 {
		return psql.Raw("NULL")
	}

	return psql.Quote("event", "id").In(bob.ExpressionFunc(func(ctx context.Context, w io.StringWriter, d bob.Dialect, start int) ([]any, error) {
		pkPairs := make([]bob.Expression, len(o))
		for i, row := range o {
			pkPairs[i] = row.primaryKeyVals()
		}
		return bob.ExpressSlice(ctx, w, d, start, pkPairs, "", ", ", "")
	}))
}

// copyMatchingRows finds models in the given slice that have the same primary key
// then it first copies the existing relationships from the old model to the new model
// and then replaces the old model in the slice with the new model
func (o EventSlice) copyMatchingRows(from ...*Event) {
	for i, old := range o {
		for _, new := range from {
			if new.ID != old.ID {
				continue
			}
			new.R = old.R
			o[i] = new
			break
		}
	}
}

// UpdateMod modifies an update query with "WHERE primary_key IN (o...)"
func (o EventSlice) UpdateMod() bob.Mod[*dialect.UpdateQuery] {
	return bob.ModFunc[*dialect.UpdateQuery](func(q *dialect.UpdateQuery) {
		q.AppendHooks(func(ctx context.Context, exec bob.Executor) (context.Context, error) {
			return Events.BeforeUpdateHooks.RunHooks(ctx, exec, o)
		})

		q.AppendLoader(bob.LoaderFunc(func(ctx context.Context, exec bob.Executor, retrieved any) error {
			var err error
			switch retrieved := retrieved.(type) {
			case *Event:
				o.copyMatchingRows(retrieved)
			case []*Event:
				o.copyMatchingRows(retrieved...)
			case EventSlice:
				o.copyMatchingRows(retrieved...)
			default:
				// If the retrieved value is not a Event or a slice of Event
				// then run the AfterUpdateHooks on the slice
				_, err = Events.AfterUpdateHooks.RunHooks(ctx, exec, o)
			}

			return err
		}))

		q.AppendWhere(o.pkIN())
	})
}

// DeleteMod modifies an delete query with "WHERE primary_key IN (o...)"
func (o EventSlice) DeleteMod() bob.Mod[*dialect.DeleteQuery] {
	return bob.ModFunc[*dialect.DeleteQuery](func(q *dialect.DeleteQuery) {
		q.AppendHooks(func(ctx context.Context, exec bob.Executor) (context.Context, error) {
			return Events.BeforeDeleteHooks.RunHooks(ctx, exec, o)
		})

		q.AppendLoader(bob.LoaderFunc(func(ctx context.Context, exec bob.Executor, retrieved any) error {
			var err error
			switch retrieved := retrieved.(type) {
			case *Event:
				o.copyMatchingRows(retrieved)
			case []*Event:
				o.copyMatchingRows(retrieved...)
			case EventSlice:
				o.copyMatchingRows(retrieved...)
			default:
				// If the retrieved value is not a Event or a slice of Event
				// then run the AfterDeleteHooks on the slice
				_, err = Events.AfterDeleteHooks.RunHooks(ctx, exec, o)
			}

			return err
		}))

		q.AppendWhere(o.pkIN())
	})
}

func (o EventSlice) UpdateAll(ctx context.Context, exec bob.Executor, vals EventSetter) error {
	if len(o) == 0 {
		return nil
	}

	_, err := Events.Update(vals.UpdateMod(), o.UpdateMod()).All(ctx, exec)
	return err
}

func (o EventSlice) DeleteAll(ctx context.Context, exec bob.Executor) error {
	if len(o) == 0 {
		return nil
	}

	_, err := Events.Delete(o.DeleteMod()).Exec(ctx, exec)
	return err
}

func (o EventSlice) ReloadAll(ctx context.Context, exec bob.Executor) error {
	if len(o) == 0 {
		return nil
	}

	o2, err := Events.Query(sm.Where(o.pkIN())).All(ctx, exec)
	if err != nil {
		return err
	}

	o.copyMatchingRows(o2...)

	return nil
}

// AnalysisProto starts a query for related objects on analysis_proto
func (o *Event) AnalysisProto(mods ...bob.Mod[*dialect.SelectQuery]) AnalysisProtosQuery {
	return AnalysisProtos.Query(append(mods,
		sm.Where(AnalysisProtos.Columns.EventID.EQ(psql.Arg(o.ID))),
	)...)
}

func (os EventSlice) AnalysisProto(mods ...bob.Mod[*dialect.SelectQuery]) AnalysisProtosQuery {
	pkID := make(pgtypes.Array[int32], 0, len(os))
	for _, o := range os {
		if o == nil {
			continue
		}
		pkID = append(pkID, o.ID)
	}
	PKArgExpr := psql.Select(sm.Columns(
		psql.F("unnest", psql.Cast(psql.Arg(pkID), "integer[]")),
	))

	return AnalysisProtos.Query(append(mods,
		sm.Where(psql.Group(AnalysisProtos.Columns.EventID).OP("IN", PKArgExpr)),
	)...)
}

// CCars starts a query for related objects on c_car
func (o *Event) CCars(mods ...bob.Mod[*dialect.SelectQuery]) CCarsQuery {
	return CCars.Query(append(mods,
		sm.Where(CCars.Columns.EventID.EQ(psql.Arg(o.ID))),
	)...)
}

func (os EventSlice) CCars(mods ...bob.Mod[*dialect.SelectQuery]) CCarsQuery {
	pkID := make(pgtypes.Array[int32], 0, len(os))
	for _, o := range os {
		if o == nil {
			continue
		}
		pkID = append(pkID, o.ID)
	}
	PKArgExpr := psql.Select(sm.Columns(
		psql.F("unnest", psql.Cast(psql.Arg(pkID), "integer[]")),
	))

	return CCars.Query(append(mods,
		sm.Where(psql.Group(CCars.Columns.EventID).OP("IN", PKArgExpr)),
	)...)
}

// CCarClasses starts a query for related objects on c_car_class
func (o *Event) CCarClasses(mods ...bob.Mod[*dialect.SelectQuery]) CCarClassesQuery {
	return CCarClasses.Query(append(mods,
		sm.Where(CCarClasses.Columns.EventID.EQ(psql.Arg(o.ID))),
	)...)
}

func (os EventSlice) CCarClasses(mods ...bob.Mod[*dialect.SelectQuery]) CCarClassesQuery {
	pkID := make(pgtypes.Array[int32], 0, len(os))
	for _, o := range os {
		if o == nil {
			continue
		}
		pkID = append(pkID, o.ID)
	}
	PKArgExpr := psql.Select(sm.Columns(
		psql.F("unnest", psql.Cast(psql.Arg(pkID), "integer[]")),
	))

	return CCarClasses.Query(append(mods,
		sm.Where(psql.Group(CCarClasses.Columns.EventID).OP("IN", PKArgExpr)),
	)...)
}

// CCarEntries starts a query for related objects on c_car_entry
func (o *Event) CCarEntries(mods ...bob.Mod[*dialect.SelectQuery]) CCarEntriesQuery {
	return CCarEntries.Query(append(mods,
		sm.Where(CCarEntries.Columns.EventID.EQ(psql.Arg(o.ID))),
	)...)
}

func (os EventSlice) CCarEntries(mods ...bob.Mod[*dialect.SelectQuery]) CCarEntriesQuery {
	pkID := make(pgtypes.Array[int32], 0, len(os))
	for _, o := range os {
		if o == nil {
			continue
		}
		pkID = append(pkID, o.ID)
	}
	PKArgExpr := psql.Select(sm.Columns(
		psql.F("unnest", psql.Cast(psql.Arg(pkID), "integer[]")),
	))

	return CCarEntries.Query(append(mods,
		sm.Where(psql.Group(CCarEntries.Columns.EventID).OP("IN", PKArgExpr)),
	)...)
}

// Tenant starts a query for related objects on tenant
func (o *Event) Tenant(mods ...bob.Mod[*dialect.SelectQuery]) TenantsQuery {
	return Tenants.Query(append(mods,
		sm.Where(Tenants.Columns.ID.EQ(psql.Arg(o.TenantID))),
	)...)
}

func (os EventSlice) Tenant(mods ...bob.Mod[*dialect.SelectQuery]) TenantsQuery {
	pkTenantID := make(pgtypes.Array[int32], 0, len(os))
	for _, o := range os {
		if o == nil {
			continue
		}
		pkTenantID = append(pkTenantID, o.TenantID)
	}
	PKArgExpr := psql.Select(sm.Columns(
		psql.F("unnest", psql.Cast(psql.Arg(pkTenantID), "integer[]")),
	))

	return Tenants.Query(append(mods,
		sm.Where(psql.Group(Tenants.Columns.ID).OP("IN", PKArgExpr)),
	)...)
}

// Track starts a query for related objects on track
func (o *Event) Track(mods ...bob.Mod[*dialect.SelectQuery]) TracksQuery {
	return Tracks.Query(append(mods,
		sm.Where(Tracks.Columns.ID.EQ(psql.Arg(o.TrackID))),
	)...)
}

func (os EventSlice) Track(mods ...bob.Mod[*dialect.SelectQuery]) TracksQuery {
	pkTrackID := make(pgtypes.Array[int32], 0, len(os))
	for _, o := range os {
		if o == nil {
			continue
		}
		pkTrackID = append(pkTrackID, o.TrackID)
	}
	PKArgExpr := psql.Select(sm.Columns(
		psql.F("unnest", psql.Cast(psql.Arg(pkTrackID), "integer[]")),
	))

	return Tracks.Query(append(mods,
		sm.Where(psql.Group(Tracks.Columns.ID).OP("IN", PKArgExpr)),
	)...)
}

// EventExt starts a query for related objects on event_ext
func (o *Event) EventExt(mods ...bob.Mod[*dialect.SelectQuery]) EventExtsQuery {
	return EventExts.Query(append(mods,
		sm.Where(EventExts.Columns.EventID.EQ(psql.Arg(o.ID))),
	)...)
}

func (os EventSlice) EventExt(mods ...bob.Mod[*dialect.SelectQuery]) EventExtsQuery {
	pkID := make(pgtypes.Array[int32], 0, len(os))
	for _, o := range os {
		if o == nil {
			continue
		}
		pkID = append(pkID, o.ID)
	}
	PKArgExpr := psql.Select(sm.Columns(
		psql.F("unnest", psql.Cast(psql.Arg(pkID), "integer[]")),
	))

	return EventExts.Query(append(mods,
		sm.Where(psql.Group(EventExts.Columns.EventID).OP("IN", PKArgExpr)),
	)...)
}

// RSInfos starts a query for related objects on rs_info
func (o *Event) RSInfos(mods ...bob.Mod[*dialect.SelectQuery]) RSInfosQuery {
	return RSInfos.Query(append(mods,
		sm.Where(RSInfos.Columns.EventID.EQ(psql.Arg(o.ID))),
	)...)
}

func (os EventSlice) RSInfos(mods ...bob.Mod[*dialect.SelectQuery]) RSInfosQuery {
	pkID := make(pgtypes.Array[int32], 0, len(os))
	for _, o := range os {
		if o == nil {
			continue
		}
		pkID = append(pkID, o.ID)
	}
	PKArgExpr := psql.Select(sm.Columns(
		psql.F("unnest", psql.Cast(psql.Arg(pkID), "integer[]")),
	))

	return RSInfos.Query(append(mods,
		sm.Where(psql.Group(RSInfos.Columns.EventID).OP("IN", PKArgExpr)),
	)...)
}

func insertEventAnalysisProto0(ctx context.Context, exec bob.Executor, analysisProto1 *AnalysisProtoSetter, event0 *Event) (*AnalysisProto, error) {
	analysisProto1.EventID = omit.From(event0.ID)

	ret, err := AnalysisProtos.Insert(analysisProto1).One(ctx, exec)
	if err != nil {
		return ret, fmt.Errorf("insertEventAnalysisProto0: %w", err)
	}

	return ret, nil
}

func attachEventAnalysisProto0(ctx context.Context, exec bob.Executor, count int, analysisProto1 *AnalysisProto, event0 *Event) (*AnalysisProto, error) {
	setter := &AnalysisProtoSetter{
		EventID: omit.From(event0.ID),
	}

	err := analysisProto1.Update(ctx, exec, setter)
	if err != nil {
		return nil, fmt.Errorf("attachEventAnalysisProto0: %w", err)
	}

	return analysisProto1, nil
}

func (event0 *Event) InsertAnalysisProto(ctx context.Context, exec bob.Executor, related *AnalysisProtoSetter) error {
	var err error

	analysisProto1, err := insertEventAnalysisProto0(ctx, exec, related, event0)
	if err != nil {
		return err
	}

	event0.R.AnalysisProto = analysisProto1

	analysisProto1.R.Event = event0

	return nil
}

func (event0 *Event) AttachAnalysisProto(ctx context.Context, exec bob.Executor, analysisProto1 *AnalysisProto) error {
	var err error

	_, err = attachEventAnalysisProto0(ctx, exec, 1, analysisProto1, event0)
	if err != nil {
		return err
	}

	event0.R.AnalysisProto = analysisProto1

	analysisProto1.R.Event = event0

	return nil
}

func insertEventCCars0(ctx context.Context, exec bob.Executor, cCars1 []*CCarSetter, event0 *Event) (CCarSlice, error) {
	for i := range cCars1 {
		cCars1[i].EventID = omit.From(event0.ID)
	}

	ret, err := CCars.Insert(bob.ToMods(cCars1...)).All(ctx, exec)
	if err != nil {
		return ret, fmt.Errorf("insertEventCCars0: %w", err)
	}

	return ret, nil
}

func attachEventCCars0(ctx context.Context, exec bob.Executor, count int, cCars1 CCarSlice, event0 *Event) (CCarSlice, error) {
	setter := &CCarSetter{
		EventID: omit.From(event0.ID),
	}

	err := cCars1.UpdateAll(ctx, exec, *setter)
	if err != nil {
		return nil, fmt.Errorf("attachEventCCars0: %w", err)
	}

	return cCars1, nil
}

func (event0 *Event) InsertCCars(ctx context.Context, exec bob.Executor, related ...*CCarSetter) error {
	if len(related) == 0 {
		return nil
	}

	var err error

	cCars1, err := insertEventCCars0(ctx, exec, related, event0)
	if err != nil {
		return err
	}

	event0.R.CCars = append(event0.R.CCars, cCars1...)

	for _, rel := range cCars1 {
		rel.R.Event = event0
	}
	return nil
}

func (event0 *Event) AttachCCars(ctx context.Context, exec bob.Executor, related ...*CCar) error {
	if len(related) == 0 {
		return nil
	}

	var err error
	cCars1 := CCarSlice(related)

	_, err = attachEventCCars0(ctx, exec, len(related), cCars1, event0)
	if err != nil {
		return err
	}

	event0.R.CCars = append(event0.R.CCars, cCars1...)

	for _, rel := range related {
		rel.R.Event = event0
	}

	return nil
}

func insertEventCCarClasses0(ctx context.Context, exec bob.Executor, cCarClasses1 []*CCarClassSetter, event0 *Event) (CCarClassSlice, error) {
	for i := range cCarClasses1 {
		cCarClasses1[i].EventID = omit.From(event0.ID)
	}

	ret, err := CCarClasses.Insert(bob.ToMods(cCarClasses1...)).All(ctx, exec)
	if err != nil {
		return ret, fmt.Errorf("insertEventCCarClasses0: %w", err)
	}

	return ret, nil
}

func attachEventCCarClasses0(ctx context.Context, exec bob.Executor, count int, cCarClasses1 CCarClassSlice, event0 *Event) (CCarClassSlice, error) {
	setter := &CCarClassSetter{
		EventID: omit.From(event0.ID),
	}

	err := cCarClasses1.UpdateAll(ctx, exec, *setter)
	if err != nil {
		return nil, fmt.Errorf("attachEventCCarClasses0: %w", err)
	}

	return cCarClasses1, nil
}

func (event0 *Event) InsertCCarClasses(ctx context.Context, exec bob.Executor, related ...*CCarClassSetter) error {
	if len(related) == 0 {
		return nil
	}

	var err error

	cCarClasses1, err := insertEventCCarClasses0(ctx, exec, related, event0)
	if err != nil {
		return err
	}

	event0.R.CCarClasses = append(event0.R.CCarClasses, cCarClasses1...)

	for _, rel := range cCarClasses1 {
		rel.R.Event = event0
	}
	return nil
}

func (event0 *Event) AttachCCarClasses(ctx context.Context, exec bob.Executor, related ...*CCarClass) error {
	if len(related) == 0 {
		return nil
	}

	var err error
	cCarClasses1 := CCarClassSlice(related)

	_, err = attachEventCCarClasses0(ctx, exec, len(related), cCarClasses1, event0)
	if err != nil {
		return err
	}

	event0.R.CCarClasses = append(event0.R.CCarClasses, cCarClasses1...)

	for _, rel := range related {
		rel.R.Event = event0
	}

	return nil
}

func insertEventCCarEntries0(ctx context.Context, exec bob.Executor, cCarEntries1 []*CCarEntrySetter, event0 *Event) (CCarEntrySlice, error) {
	for i := range cCarEntries1 {
		cCarEntries1[i].EventID = omit.From(event0.ID)
	}

	ret, err := CCarEntries.Insert(bob.ToMods(cCarEntries1...)).All(ctx, exec)
	if err != nil {
		return ret, fmt.Errorf("insertEventCCarEntries0: %w", err)
	}

	return ret, nil
}

func attachEventCCarEntries0(ctx context.Context, exec bob.Executor, count int, cCarEntries1 CCarEntrySlice, event0 *Event) (CCarEntrySlice, error) {
	setter := &CCarEntrySetter{
		EventID: omit.From(event0.ID),
	}

	err := cCarEntries1.UpdateAll(ctx, exec, *setter)
	if err != nil {
		return nil, fmt.Errorf("attachEventCCarEntries0: %w", err)
	}

	return cCarEntries1, nil
}

func (event0 *Event) InsertCCarEntries(ctx context.Context, exec bob.Executor, related ...*CCarEntrySetter) error {
	if len(related) == 0 {
		return nil
	}

	var err error

	cCarEntries1, err := insertEventCCarEntries0(ctx, exec, related, event0)
	if err != nil {
		return err
	}

	event0.R.CCarEntries = append(event0.R.CCarEntries, cCarEntries1...)

	for _, rel := range cCarEntries1 {
		rel.R.Event = event0
	}
	return nil
}

func (event0 *Event) AttachCCarEntries(ctx context.Context, exec bob.Executor, related ...*CCarEntry) error {
	if len(related) == 0 {
		return nil
	}

	var err error
	cCarEntries1 := CCarEntrySlice(related)

	_, err = attachEventCCarEntries0(ctx, exec, len(related), cCarEntries1, event0)
	if err != nil {
		return err
	}

	event0.R.CCarEntries = append(event0.R.CCarEntries, cCarEntries1...)

	for _, rel := range related {
		rel.R.Event = event0
	}

	return nil
}

func attachEventTenant0(ctx context.Context, exec bob.Executor, count int, event0 *Event, tenant1 *Tenant) (*Event, error) {
	setter := &EventSetter{
		TenantID: omit.From(tenant1.ID),
	}

	err := event0.Update(ctx, exec, setter)
	if err != nil {
		return nil, fmt.Errorf("attachEventTenant0: %w", err)
	}

	return event0, nil
}

func (event0 *Event) InsertTenant(ctx context.Context, exec bob.Executor, related *TenantSetter) error {
	var err error

	tenant1, err := Tenants.Insert(related).One(ctx, exec)
	if err != nil {
		return fmt.Errorf("inserting related objects: %w", err)
	}

	_, err = attachEventTenant0(ctx, exec, 1, event0, tenant1)
	if err != nil {
		return err
	}

	event0.R.Tenant = tenant1

	tenant1.R.Events = append(tenant1.R.Events, event0)

	return nil
}

func (event0 *Event) AttachTenant(ctx context.Context, exec bob.Executor, tenant1 *Tenant) error {
	var err error

	_, err = attachEventTenant0(ctx, exec, 1, event0, tenant1)
	if err != nil {
		return err
	}

	event0.R.Tenant = tenant1

	tenant1.R.Events = append(tenant1.R.Events, event0)

	return nil
}

func attachEventTrack0(ctx context.Context, exec bob.Executor, count int, event0 *Event, track1 *Track) (*Event, error) {
	setter := &EventSetter{
		TrackID: omit.From(track1.ID),
	}

	err := event0.Update(ctx, exec, setter)
	if err != nil {
		return nil, fmt.Errorf("attachEventTrack0: %w", err)
	}

	return event0, nil
}

func (event0 *Event) InsertTrack(ctx context.Context, exec bob.Executor, related *TrackSetter) error {
	var err error

	track1, err := Tracks.Insert(related).One(ctx, exec)
	if err != nil {
		return fmt.Errorf("inserting related objects: %w", err)
	}

	_, err = attachEventTrack0(ctx, exec, 1, event0, track1)
	if err != nil {
		return err
	}

	event0.R.Track = track1

	track1.R.Events = append(track1.R.Events, event0)

	return nil
}

func (event0 *Event) AttachTrack(ctx context.Context, exec bob.Executor, track1 *Track) error {
	var err error

	_, err = attachEventTrack0(ctx, exec, 1, event0, track1)
	if err != nil {
		return err
	}

	event0.R.Track = track1

	track1.R.Events = append(track1.R.Events, event0)

	return nil
}

func insertEventEventExt0(ctx context.Context, exec bob.Executor, eventExt1 *EventExtSetter, event0 *Event) (*EventExt, error) {
	eventExt1.EventID = omit.From(event0.ID)

	ret, err := EventExts.Insert(eventExt1).One(ctx, exec)
	if err != nil {
		return ret, fmt.Errorf("insertEventEventExt0: %w", err)
	}

	return ret, nil
}

func attachEventEventExt0(ctx context.Context, exec bob.Executor, count int, eventExt1 *EventExt, event0 *Event) (*EventExt, error) {
	setter := &EventExtSetter{
		EventID: omit.From(event0.ID),
	}

	err := eventExt1.Update(ctx, exec, setter)
	if err != nil {
		return nil, fmt.Errorf("attachEventEventExt0: %w", err)
	}

	return eventExt1, nil
}

func (event0 *Event) InsertEventExt(ctx context.Context, exec bob.Executor, related *EventExtSetter) error {
	var err error

	eventExt1, err := insertEventEventExt0(ctx, exec, related, event0)
	if err != nil {
		return err
	}

	event0.R.EventExt = eventExt1

	eventExt1.R.Event = event0

	return nil
}

func (event0 *Event) AttachEventExt(ctx context.Context, exec bob.Executor, eventExt1 *EventExt) error {
	var err error

	_, err = attachEventEventExt0(ctx, exec, 1, eventExt1, event0)
	if err != nil {
		return err
	}

	event0.R.EventExt = eventExt1

	eventExt1.R.Event = event0

	return nil
}

func insertEventRSInfos0(ctx context.Context, exec bob.Executor, rsInfos1 []*RSInfoSetter, event0 *Event) (RSInfoSlice, error) {
	for i := range rsInfos1 {
		rsInfos1[i].EventID = omit.From(event0.ID)
	}

	ret, err := RSInfos.Insert(bob.ToMods(rsInfos1...)).All(ctx, exec)
	if err != nil {
		return ret, fmt.Errorf("insertEventRSInfos0: %w", err)
	}

	return ret, nil
}

func attachEventRSInfos0(ctx context.Context, exec bob.Executor, count int, rsInfos1 RSInfoSlice, event0 *Event) (RSInfoSlice, error) {
	setter := &RSInfoSetter{
		EventID: omit.From(event0.ID),
	}

	err := rsInfos1.UpdateAll(ctx, exec, *setter)
	if err != nil {
		return nil, fmt.Errorf("attachEventRSInfos0: %w", err)
	}

	return rsInfos1, nil
}

func (event0 *Event) InsertRSInfos(ctx context.Context, exec bob.Executor, related ...*RSInfoSetter) error {
	if len(related) == 0 {
		return nil
	}

	var err error

	rsInfos1, err := insertEventRSInfos0(ctx, exec, related, event0)
	if err != nil {
		return err
	}

	event0.R.RSInfos = append(event0.R.RSInfos, rsInfos1...)

	for _, rel := range rsInfos1 {
		rel.R.Event = event0
	}
	return nil
}

func (event0 *Event) AttachRSInfos(ctx context.Context, exec bob.Executor, related ...*RSInfo) error {
	if len(related) == 0 {
		return nil
	}

	var err error
	rsInfos1 := RSInfoSlice(related)

	_, err = attachEventRSInfos0(ctx, exec, len(related), rsInfos1, event0)
	if err != nil {
		return err
	}

	event0.R.RSInfos = append(event0.R.RSInfos, rsInfos1...)

	for _, rel := range related {
		rel.R.Event = event0
	}

	return nil
}

type eventWhere[Q psql.Filterable] struct {
	ID                   psql.WhereMod[Q, int32]
	EventKey             psql.WhereMod[Q, string]
	Name                 psql.WhereMod[Q, string]
	Description          psql.WhereNullMod[Q, string]
	EventTime            psql.WhereMod[Q, time.Time]
	RaceloggerVersion    psql.WhereMod[Q, string]
	TeamRacing           psql.WhereMod[Q, bool]
	MultiClass           psql.WhereMod[Q, bool]
	NumCarTypes          psql.WhereMod[Q, int32]
	NumCarClasses        psql.WhereMod[Q, int32]
	IrSessionID          psql.WhereNullMod[Q, int32]
	TrackID              psql.WhereMod[Q, int32]
	PitSpeed             psql.WhereMod[Q, decimal.Decimal]
	ReplayMinTimestamp   psql.WhereMod[Q, time.Time]
	ReplayMinSessionTime psql.WhereMod[Q, decimal.Decimal]
	ReplayMaxSessionTime psql.WhereMod[Q, decimal.Decimal]
	Sessions             psql.WhereMod[Q, mytypes.EventSessionSlice]
	IrSubSessionID       psql.WhereMod[Q, int32]
	TenantID             psql.WhereMod[Q, int32]
	TireInfos            psql.WhereNullMod[Q, mytypes.TireInfoSlice]
}

func (eventWhere[Q]) AliasedAs(alias string) eventWhere[Q] {
	return buildEventWhere[Q](buildEventColumns(alias))
}

func buildEventWhere[Q psql.Filterable](cols eventColumns) eventWhere[Q] {
	return eventWhere[Q]{
		ID:                   psql.Where[Q, int32](cols.ID),
		EventKey:             psql.Where[Q, string](cols.EventKey),
		Name:                 psql.Where[Q, string](cols.Name),
		Description:          psql.WhereNull[Q, string](cols.Description),
		EventTime:            psql.Where[Q, time.Time](cols.EventTime),
		RaceloggerVersion:    psql.Where[Q, string](cols.RaceloggerVersion),
		TeamRacing:           psql.Where[Q, bool](cols.TeamRacing),
		MultiClass:           psql.Where[Q, bool](cols.MultiClass),
		NumCarTypes:          psql.Where[Q, int32](cols.NumCarTypes),
		NumCarClasses:        psql.Where[Q, int32](cols.NumCarClasses),
		IrSessionID:          psql.WhereNull[Q, int32](cols.IrSessionID),
		TrackID:              psql.Where[Q, int32](cols.TrackID),
		PitSpeed:             psql.Where[Q, decimal.Decimal](cols.PitSpeed),
		ReplayMinTimestamp:   psql.Where[Q, time.Time](cols.ReplayMinTimestamp),
		ReplayMinSessionTime: psql.Where[Q, decimal.Decimal](cols.ReplayMinSessionTime),
		ReplayMaxSessionTime: psql.Where[Q, decimal.Decimal](cols.ReplayMaxSessionTime),
		Sessions:             psql.Where[Q, mytypes.EventSessionSlice](cols.Sessions),
		IrSubSessionID:       psql.Where[Q, int32](cols.IrSubSessionID),
		TenantID:             psql.Where[Q, int32](cols.TenantID),
		TireInfos:            psql.WhereNull[Q, mytypes.TireInfoSlice](cols.TireInfos),
	}
}

func (o *Event) Preload(name string, retrieved any) error {
	if o == nil {
		return nil
	}

	switch name {
	case "AnalysisProto":
		rel, ok := retrieved.(*AnalysisProto)
		if !ok {
			return fmt.Errorf("event cannot load %T as %q", retrieved, name)
		}

		o.R.AnalysisProto = rel

		if rel != nil {
			rel.R.Event = o
		}
		return nil
	case "CCars":
		rels, ok := retrieved.(CCarSlice)
		if !ok {
			return fmt.Errorf("event cannot load %T as %q", retrieved, name)
		}

		o.R.CCars = rels

		for _, rel := range rels {
			if rel != nil {
				rel.R.Event = o
			}
		}
		return nil
	case "CCarClasses":
		rels, ok := retrieved.(CCarClassSlice)
		if !ok {
			return fmt.Errorf("event cannot load %T as %q", retrieved, name)
		}

		o.R.CCarClasses = rels

		for _, rel := range rels {
			if rel != nil {
				rel.R.Event = o
			}
		}
		return nil
	case "CCarEntries":
		rels, ok := retrieved.(CCarEntrySlice)
		if !ok {
			return fmt.Errorf("event cannot load %T as %q", retrieved, name)
		}

		o.R.CCarEntries = rels

		for _, rel := range rels {
			if rel != nil {
				rel.R.Event = o
			}
		}
		return nil
	case "Tenant":
		rel, ok := retrieved.(*Tenant)
		if !ok {
			return fmt.Errorf("event cannot load %T as %q", retrieved, name)
		}

		o.R.Tenant = rel

		if rel != nil {
			rel.R.Events = EventSlice{o}
		}
		return nil
	case "Track":
		rel, ok := retrieved.(*Track)
		if !ok {
			return fmt.Errorf("event cannot load %T as %q", retrieved, name)
		}

		o.R.Track = rel

		if rel != nil {
			rel.R.Events = EventSlice{o}
		}
		return nil
	case "EventExt":
		rel, ok := retrieved.(*EventExt)
		if !ok {
			return fmt.Errorf("event cannot load %T as %q", retrieved, name)
		}

		o.R.EventExt = rel

		if rel != nil {
			rel.R.Event = o
		}
		return nil
	case "RSInfos":
		rels, ok := retrieved.(RSInfoSlice)
		if !ok {
			return fmt.Errorf("event cannot load %T as %q", retrieved, name)
		}

		o.R.RSInfos = rels

		for _, rel := range rels {
			if rel != nil {
				rel.R.Event = o
			}
		}
		return nil
	default:
		return fmt.Errorf("event has no relationship %q", name)
	}
}

type eventPreloader struct {
	AnalysisProto func(...psql.PreloadOption) psql.Preloader
	Tenant        func(...psql.PreloadOption) psql.Preloader
	Track         func(...psql.PreloadOption) psql.Preloader
	EventExt      func(...psql.PreloadOption) psql.Preloader
}

func buildEventPreloader() eventPreloader {
	return eventPreloader{
		AnalysisProto: func(opts ...psql.PreloadOption) psql.Preloader {
			return psql.Preload[*AnalysisProto, AnalysisProtoSlice](psql.PreloadRel{
				Name: "AnalysisProto",
				Sides: []psql.PreloadSide{
					{
						From:        Events,
						To:          AnalysisProtos,
						FromColumns: []string{"id"},
						ToColumns:   []string{"event_id"},
					},
				},
			}, AnalysisProtos.Columns.Names(), opts...)
		},
		Tenant: func(opts ...psql.PreloadOption) psql.Preloader {
			return psql.Preload[*Tenant, TenantSlice](psql.PreloadRel{
				Name: "Tenant",
				Sides: []psql.PreloadSide{
					{
						From:        Events,
						To:          Tenants,
						FromColumns: []string{"tenant_id"},
						ToColumns:   []string{"id"},
					},
				},
			}, Tenants.Columns.Names(), opts...)
		},
		Track: func(opts ...psql.PreloadOption) psql.Preloader {
			return psql.Preload[*Track, TrackSlice](psql.PreloadRel{
				Name: "Track",
				Sides: []psql.PreloadSide{
					{
						From:        Events,
						To:          Tracks,
						FromColumns: []string{"track_id"},
						ToColumns:   []string{"id"},
					},
				},
			}, Tracks.Columns.Names(), opts...)
		},
		EventExt: func(opts ...psql.PreloadOption) psql.Preloader {
			return psql.Preload[*EventExt, EventExtSlice](psql.PreloadRel{
				Name: "EventExt",
				Sides: []psql.PreloadSide{
					{
						From:        Events,
						To:          EventExts,
						FromColumns: []string{"id"},
						ToColumns:   []string{"event_id"},
					},
				},
			}, EventExts.Columns.Names(), opts...)
		},
	}
}

type eventThenLoader[Q orm.Loadable] struct {
	AnalysisProto func(...bob.Mod[*dialect.SelectQuery]) orm.Loader[Q]
	CCars         func(...bob.Mod[*dialect.SelectQuery]) orm.Loader[Q]
	CCarClasses   func(...bob.Mod[*dialect.SelectQuery]) orm.Loader[Q]
	CCarEntries   func(...bob.Mod[*dialect.SelectQuery]) orm.Loader[Q]
	Tenant        func(...bob.Mod[*dialect.SelectQuery]) orm.Loader[Q]
	Track         func(...bob.Mod[*dialect.SelectQuery]) orm.Loader[Q]
	EventExt      func(...bob.Mod[*dialect.SelectQuery]) orm.Loader[Q]
	RSInfos       func(...bob.Mod[*dialect.SelectQuery]) orm.Loader[Q]
}

func buildEventThenLoader[Q orm.Loadable]() eventThenLoader[Q] {
	type AnalysisProtoLoadInterface interface {
		LoadAnalysisProto(context.Context, bob.Executor, ...bob.Mod[*dialect.SelectQuery]) error
	}
	type CCarsLoadInterface interface {
		LoadCCars(context.Context, bob.Executor, ...bob.Mod[*dialect.SelectQuery]) error
	}
	type CCarClassesLoadInterface interface {
		LoadCCarClasses(context.Context, bob.Executor, ...bob.Mod[*dialect.SelectQuery]) error
	}
	type CCarEntriesLoadInterface interface {
		LoadCCarEntries(context.Context, bob.Executor, ...bob.Mod[*dialect.SelectQuery]) error
	}
	type TenantLoadInterface interface {
		LoadTenant(context.Context, bob.Executor, ...bob.Mod[*dialect.SelectQuery]) error
	}
	type TrackLoadInterface interface {
		LoadTrack(context.Context, bob.Executor, ...bob.Mod[*dialect.SelectQuery]) error
	}
	type EventExtLoadInterface interface {
		LoadEventExt(context.Context, bob.Executor, ...bob.Mod[*dialect.SelectQuery]) error
	}
	type RSInfosLoadInterface interface {
		LoadRSInfos(context.Context, bob.Executor, ...bob.Mod[*dialect.SelectQuery]) error
	}

	return eventThenLoader[Q]{
		AnalysisProto: thenLoadBuilder[Q](
			"AnalysisProto",
			func(ctx context.Context, exec bob.Executor, retrieved AnalysisProtoLoadInterface, mods ...bob.Mod[*dialect.SelectQuery]) error {
				return retrieved.LoadAnalysisProto(ctx, exec, mods...)
			},
		),
		CCars: thenLoadBuilder[Q](
			"CCars",
			func(ctx context.Context, exec bob.Executor, retrieved CCarsLoadInterface, mods ...bob.Mod[*dialect.SelectQuery]) error {
				return retrieved.LoadCCars(ctx, exec, mods...)
			},
		),
		CCarClasses: thenLoadBuilder[Q](
			"CCarClasses",
			func(ctx context.Context, exec bob.Executor, retrieved CCarClassesLoadInterface, mods ...bob.Mod[*dialect.SelectQuery]) error {
				return retrieved.LoadCCarClasses(ctx, exec, mods...)
			},
		),
		CCarEntries: thenLoadBuilder[Q](
			"CCarEntries",
			func(ctx context.Context, exec bob.Executor, retrieved CCarEntriesLoadInterface, mods ...bob.Mod[*dialect.SelectQuery]) error {
				return retrieved.LoadCCarEntries(ctx, exec, mods...)
			},
		),
		Tenant: thenLoadBuilder[Q](
			"Tenant",
			func(ctx context.Context, exec bob.Executor, retrieved TenantLoadInterface, mods ...bob.Mod[*dialect.SelectQuery]) error {
				return retrieved.LoadTenant(ctx, exec, mods...)
			},
		),
		Track: thenLoadBuilder[Q](
			"Track",
			func(ctx context.Context, exec bob.Executor, retrieved TrackLoadInterface, mods ...bob.Mod[*dialect.SelectQuery]) error {
				return retrieved.LoadTrack(ctx, exec, mods...)
			},
		),
		EventExt: thenLoadBuilder[Q](
			"EventExt",
			func(ctx context.Context, exec bob.Executor, retrieved EventExtLoadInterface, mods ...bob.Mod[*dialect.SelectQuery]) error {
				return retrieved.LoadEventExt(ctx, exec, mods...)
			},
		),
		RSInfos: thenLoadBuilder[Q](
			"RSInfos",
			func(ctx context.Context, exec bob.Executor, retrieved RSInfosLoadInterface, mods ...bob.Mod[*dialect.SelectQuery]) error {
				return retrieved.LoadRSInfos(ctx, exec, mods...)
			},
		),
	}
}

// LoadAnalysisProto loads the event's AnalysisProto into the .R struct
func (o *Event) LoadAnalysisProto(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if o == nil {
		return nil
	}

	// Reset the relationship
	o.R.AnalysisProto = nil

	related, err := o.AnalysisProto(mods...).One(ctx, exec)
	if err != nil {
		return err
	}

	related.R.Event = o

	o.R.AnalysisProto = related
	return nil
}

// LoadAnalysisProto loads the event's AnalysisProto into the .R struct
func (os EventSlice) LoadAnalysisProto(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if len(os) == 0 {
		return nil
	}

	analysisProtos, err := os.AnalysisProto(mods...).All(ctx, exec)
	if err != nil {
		return err
	}

	for _, o := range os {
		if o == nil {
			continue
		}

		for _, rel := range analysisProtos {

			if !(o.ID == rel.EventID) {
				continue
			}

			rel.R.Event = o

			o.R.AnalysisProto = rel
			break
		}
	}

	return nil
}

// LoadCCars loads the event's CCars into the .R struct
func (o *Event) LoadCCars(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if o == nil {
		return nil
	}

	// Reset the relationship
	o.R.CCars = nil

	related, err := o.CCars(mods...).All(ctx, exec)
	if err != nil {
		return err
	}

	for _, rel := range related {
		rel.R.Event = o
	}

	o.R.CCars = related
	return nil
}

// LoadCCars loads the event's CCars into the .R struct
func (os EventSlice) LoadCCars(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if len(os) == 0 {
		return nil
	}

	cCars, err := os.CCars(mods...).All(ctx, exec)
	if err != nil {
		return err
	}

	for _, o := range os {
		if o == nil {
			continue
		}

		o.R.CCars = nil
	}

	for _, o := range os {
		if o == nil {
			continue
		}

		for _, rel := range cCars {

			if !(o.ID == rel.EventID) {
				continue
			}

			rel.R.Event = o

			o.R.CCars = append(o.R.CCars, rel)
		}
	}

	return nil
}

// LoadCCarClasses loads the event's CCarClasses into the .R struct
func (o *Event) LoadCCarClasses(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if o == nil {
		return nil
	}

	// Reset the relationship
	o.R.CCarClasses = nil

	related, err := o.CCarClasses(mods...).All(ctx, exec)
	if err != nil {
		return err
	}

	for _, rel := range related {
		rel.R.Event = o
	}

	o.R.CCarClasses = related
	return nil
}

// LoadCCarClasses loads the event's CCarClasses into the .R struct
func (os EventSlice) LoadCCarClasses(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if len(os) == 0 {
		return nil
	}

	cCarClasses, err := os.CCarClasses(mods...).All(ctx, exec)
	if err != nil {
		return err
	}

	for _, o := range os {
		if o == nil {
			continue
		}

		o.R.CCarClasses = nil
	}

	for _, o := range os {
		if o == nil {
			continue
		}

		for _, rel := range cCarClasses {

			if !(o.ID == rel.EventID) {
				continue
			}

			rel.R.Event = o

			o.R.CCarClasses = append(o.R.CCarClasses, rel)
		}
	}

	return nil
}

// LoadCCarEntries loads the event's CCarEntries into the .R struct
func (o *Event) LoadCCarEntries(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if o == nil {
		return nil
	}

	// Reset the relationship
	o.R.CCarEntries = nil

	related, err := o.CCarEntries(mods...).All(ctx, exec)
	if err != nil {
		return err
	}

	for _, rel := range related {
		rel.R.Event = o
	}

	o.R.CCarEntries = related
	return nil
}

// LoadCCarEntries loads the event's CCarEntries into the .R struct
func (os EventSlice) LoadCCarEntries(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if len(os) == 0 {
		return nil
	}

	cCarEntries, err := os.CCarEntries(mods...).All(ctx, exec)
	if err != nil {
		return err
	}

	for _, o := range os {
		if o == nil {
			continue
		}

		o.R.CCarEntries = nil
	}

	for _, o := range os {
		if o == nil {
			continue
		}

		for _, rel := range cCarEntries {

			if !(o.ID == rel.EventID) {
				continue
			}

			rel.R.Event = o

			o.R.CCarEntries = append(o.R.CCarEntries, rel)
		}
	}

	return nil
}

// LoadTenant loads the event's Tenant into the .R struct
func (o *Event) LoadTenant(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if o == nil {
		return nil
	}

	// Reset the relationship
	o.R.Tenant = nil

	related, err := o.Tenant(mods...).One(ctx, exec)
	if err != nil {
		return err
	}

	related.R.Events = EventSlice{o}

	o.R.Tenant = related
	return nil
}

// LoadTenant loads the event's Tenant into the .R struct
func (os EventSlice) LoadTenant(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if len(os) == 0 {
		return nil
	}

	tenants, err := os.Tenant(mods...).All(ctx, exec)
	if err != nil {
		return err
	}

	for _, o := range os {
		if o == nil {
			continue
		}

		for _, rel := range tenants {

			if !(o.TenantID == rel.ID) {
				continue
			}

			rel.R.Events = append(rel.R.Events, o)

			o.R.Tenant = rel
			break
		}
	}

	return nil
}

// LoadTrack loads the event's Track into the .R struct
func (o *Event) LoadTrack(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if o == nil {
		return nil
	}

	// Reset the relationship
	o.R.Track = nil

	related, err := o.Track(mods...).One(ctx, exec)
	if err != nil {
		return err
	}

	related.R.Events = EventSlice{o}

	o.R.Track = related
	return nil
}

// LoadTrack loads the event's Track into the .R struct
func (os EventSlice) LoadTrack(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if len(os) == 0 {
		return nil
	}

	tracks, err := os.Track(mods...).All(ctx, exec)
	if err != nil {
		return err
	}

	for _, o := range os {
		if o == nil {
			continue
		}

		for _, rel := range tracks {

			if !(o.TrackID == rel.ID) {
				continue
			}

			rel.R.Events = append(rel.R.Events, o)

			o.R.Track = rel
			break
		}
	}

	return nil
}

// LoadEventExt loads the event's EventExt into the .R struct
func (o *Event) LoadEventExt(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if o == nil {
		return nil
	}

	// Reset the relationship
	o.R.EventExt = nil

	related, err := o.EventExt(mods...).One(ctx, exec)
	if err != nil {
		return err
	}

	related.R.Event = o

	o.R.EventExt = related
	return nil
}

// LoadEventExt loads the event's EventExt into the .R struct
func (os EventSlice) LoadEventExt(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if len(os) == 0 {
		return nil
	}

	eventExts, err := os.EventExt(mods...).All(ctx, exec)
	if err != nil {
		return err
	}

	for _, o := range os {
		if o == nil {
			continue
		}

		for _, rel := range eventExts {

			if !(o.ID == rel.EventID) {
				continue
			}

			rel.R.Event = o

			o.R.EventExt = rel
			break
		}
	}

	return nil
}

// LoadRSInfos loads the event's RSInfos into the .R struct
func (o *Event) LoadRSInfos(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if o == nil {
		return nil
	}

	// Reset the relationship
	o.R.RSInfos = nil

	related, err := o.RSInfos(mods...).All(ctx, exec)
	if err != nil {
		return err
	}

	for _, rel := range related {
		rel.R.Event = o
	}

	o.R.RSInfos = related
	return nil
}

// LoadRSInfos loads the event's RSInfos into the .R struct
func (os EventSlice) LoadRSInfos(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if len(os) == 0 {
		return nil
	}

	rsInfos, err := os.RSInfos(mods...).All(ctx, exec)
	if err != nil {
		return err
	}

	for _, o := range os {
		if o == nil {
			continue
		}

		o.R.RSInfos = nil
	}

	for _, o := range os {
		if o == nil {
			continue
		}

		for _, rel := range rsInfos {

			if !(o.ID == rel.EventID) {
				continue
			}

			rel.R.Event = o

			o.R.RSInfos = append(o.R.RSInfos, rel)
		}
	}

	return nil
}

type eventJoins[Q dialect.Joinable] struct {
	typ           string
	AnalysisProto modAs[Q, analysisProtoColumns]
	CCars         modAs[Q, cCarColumns]
	CCarClasses   modAs[Q, cCarClassColumns]
	CCarEntries   modAs[Q, cCarEntryColumns]
	Tenant        modAs[Q, tenantColumns]
	Track         modAs[Q, trackColumns]
	EventExt      modAs[Q, eventExtColumns]
	RSInfos       modAs[Q, rsInfoColumns]
}

func (j eventJoins[Q]) aliasedAs(alias string) eventJoins[Q] {
	return buildEventJoins[Q](buildEventColumns(alias), j.typ)
}

func buildEventJoins[Q dialect.Joinable](cols eventColumns, typ string) eventJoins[Q] {
	return eventJoins[Q]{
		typ: typ,
		AnalysisProto: modAs[Q, analysisProtoColumns]{
			c: AnalysisProtos.Columns,
			f: func(to analysisProtoColumns) bob.Mod[Q] {
				mods := make(mods.QueryMods[Q], 0, 1)

				{
					mods = append(mods, dialect.Join[Q](typ, AnalysisProtos.Name().As(to.Alias())).On(
						to.EventID.EQ(cols.ID),
					))
				}

				return mods
			},
		},
		CCars: modAs[Q, cCarColumns]{
			c: CCars.Columns,
			f: func(to cCarColumns) bob.Mod[Q] {
				mods := make(mods.QueryMods[Q], 0, 1)

				{
					mods = append(mods, dialect.Join[Q](typ, CCars.Name().As(to.Alias())).On(
						to.EventID.EQ(cols.ID),
					))
				}

				return mods
			},
		},
		CCarClasses: modAs[Q, cCarClassColumns]{
			c: CCarClasses.Columns,
			f: func(to cCarClassColumns) bob.Mod[Q] {
				mods := make(mods.QueryMods[Q], 0, 1)

				{
					mods = append(mods, dialect.Join[Q](typ, CCarClasses.Name().As(to.Alias())).On(
						to.EventID.EQ(cols.ID),
					))
				}

				return mods
			},
		},
		CCarEntries: modAs[Q, cCarEntryColumns]{
			c: CCarEntries.Columns,
			f: func(to cCarEntryColumns) bob.Mod[Q] {
				mods := make(mods.QueryMods[Q], 0, 1)

				{
					mods = append(mods, dialect.Join[Q](typ, CCarEntries.Name().As(to.Alias())).On(
						to.EventID.EQ(cols.ID),
					))
				}

				return mods
			},
		},
		Tenant: modAs[Q, tenantColumns]{
			c: Tenants.Columns,
			f: func(to tenantColumns) bob.Mod[Q] {
				mods := make(mods.QueryMods[Q], 0, 1)

				{
					mods = append(mods, dialect.Join[Q](typ, Tenants.Name().As(to.Alias())).On(
						to.ID.EQ(cols.TenantID),
					))
				}

				return mods
			},
		},
		Track: modAs[Q, trackColumns]{
			c: Tracks.Columns,
			f: func(to trackColumns) bob.Mod[Q] {
				mods := make(mods.QueryMods[Q], 0, 1)

				{
					mods = append(mods, dialect.Join[Q](typ, Tracks.Name().As(to.Alias())).On(
						to.ID.EQ(cols.TrackID),
					))
				}

				return mods
			},
		},
		EventExt: modAs[Q, eventExtColumns]{
			c: EventExts.Columns,
			f: func(to eventExtColumns) bob.Mod[Q] {
				mods := make(mods.QueryMods[Q], 0, 1)

				{
					mods = append(mods, dialect.Join[Q](typ, EventExts.Name().As(to.Alias())).On(
						to.EventID.EQ(cols.ID),
					))
				}

				return mods
			},
		},
		RSInfos: modAs[Q, rsInfoColumns]{
			c: RSInfos.Columns,
			f: func(to rsInfoColumns) bob.Mod[Q] {
				mods := make(mods.QueryMods[Q], 0, 1)

				{
					mods = append(mods, dialect.Join[Q](typ, RSInfos.Name().As(to.Alias())).On(
						to.EventID.EQ(cols.ID),
					))
				}

				return mods
			},
		},
	}
}
