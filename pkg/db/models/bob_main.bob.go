// Code generated by BobGen psql v0.39.0. DO NOT EDIT.
// This file is meant to be re-generated in place and/or deleted at any time.

package models

import (
	"context"
	"database/sql"
	"errors"
	"fmt"
	"hash/maphash"

	"github.com/lib/pq"
	"github.com/stephenafamo/bob"
	"github.com/stephenafamo/bob/clause"
	"github.com/stephenafamo/bob/dialect/psql"
	"github.com/stephenafamo/bob/dialect/psql/dialect"
	"github.com/stephenafamo/bob/orm"
)

var TableNames = struct {
	AnalysisProtos   string
	CCars            string
	CCarClasses      string
	CCarDrivers      string
	CCarEntries      string
	CCarTeams        string
	CarStateProtos   string
	Events           string
	EventExts        string
	MSGStateProtos   string
	RaceStateProtos  string
	RSInfos          string
	SchemaMigrations string
	SpeedmapProtos   string
	Tenants          string
	Tracks           string
}{
	AnalysisProtos:   "analysis_proto",
	CCars:            "c_car",
	CCarClasses:      "c_car_class",
	CCarDrivers:      "c_car_driver",
	CCarEntries:      "c_car_entry",
	CCarTeams:        "c_car_team",
	CarStateProtos:   "car_state_proto",
	Events:           "event",
	EventExts:        "event_ext",
	MSGStateProtos:   "msg_state_proto",
	RaceStateProtos:  "race_state_proto",
	RSInfos:          "rs_info",
	SchemaMigrations: "schema_migrations",
	SpeedmapProtos:   "speedmap_proto",
	Tenants:          "tenant",
	Tracks:           "track",
}

var ColumnNames = struct {
	AnalysisProtos   analysisProtoColumnNames
	CCars            cCarColumnNames
	CCarClasses      cCarClassColumnNames
	CCarDrivers      cCarDriverColumnNames
	CCarEntries      cCarEntryColumnNames
	CCarTeams        cCarTeamColumnNames
	CarStateProtos   carStateProtoColumnNames
	Events           eventColumnNames
	EventExts        eventExtColumnNames
	MSGStateProtos   msgStateProtoColumnNames
	RaceStateProtos  raceStateProtoColumnNames
	RSInfos          rsInfoColumnNames
	SchemaMigrations schemaMigrationColumnNames
	SpeedmapProtos   speedmapProtoColumnNames
	Tenants          tenantColumnNames
	Tracks           trackColumnNames
}{
	AnalysisProtos: analysisProtoColumnNames{
		EventID:     "event_id",
		RecordStamp: "record_stamp",
		Protodata:   "protodata",
	},
	CCars: cCarColumnNames{
		ID:            "id",
		EventID:       "event_id",
		Name:          "name",
		NameShort:     "name_short",
		CarID:         "car_id",
		CCarClassID:   "c_car_class_id",
		FuelPCT:       "fuel_pct",
		PowerAdjust:   "power_adjust",
		WeightPenalty: "weight_penalty",
		DryTireSets:   "dry_tire_sets",
	},
	CCarClasses: cCarClassColumnNames{
		ID:         "id",
		EventID:    "event_id",
		Name:       "name",
		CarClassID: "car_class_id",
	},
	CCarDrivers: cCarDriverColumnNames{
		ID:          "id",
		CCarEntryID: "c_car_entry_id",
		DriverID:    "driver_id",
		Name:        "name",
		Initials:    "initials",
		AbbrevName:  "abbrev_name",
		Irating:     "irating",
		LicLevel:    "lic_level",
		LicSubLevel: "lic_sub_level",
		LicString:   "lic_string",
	},
	CCarEntries: cCarEntryColumnNames{
		ID:           "id",
		EventID:      "event_id",
		CCarID:       "c_car_id",
		CarIdx:       "car_idx",
		CarNumber:    "car_number",
		CarNumberRaw: "car_number_raw",
	},
	CCarTeams: cCarTeamColumnNames{
		ID:          "id",
		CCarEntryID: "c_car_entry_id",
		TeamID:      "team_id",
		Name:        "name",
	},
	CarStateProtos: carStateProtoColumnNames{
		ID:        "id",
		RSInfoID:  "rs_info_id",
		Protodata: "protodata",
	},
	Events: eventColumnNames{
		ID:                   "id",
		EventKey:             "event_key",
		Name:                 "name",
		Description:          "description",
		EventTime:            "event_time",
		RaceloggerVersion:    "racelogger_version",
		TeamRacing:           "team_racing",
		MultiClass:           "multi_class",
		NumCarTypes:          "num_car_types",
		NumCarClasses:        "num_car_classes",
		IrSessionID:          "ir_session_id",
		TrackID:              "track_id",
		PitSpeed:             "pit_speed",
		ReplayMinTimestamp:   "replay_min_timestamp",
		ReplayMinSessionTime: "replay_min_session_time",
		ReplayMaxSessionTime: "replay_max_session_time",
		Sessions:             "sessions",
		IrSubSessionID:       "ir_sub_session_id",
		TenantID:             "tenant_id",
		TireInfos:            "tire_infos",
	},
	EventExts: eventExtColumnNames{
		EventID:   "event_id",
		ExtraInfo: "extra_info",
	},
	MSGStateProtos: msgStateProtoColumnNames{
		ID:        "id",
		RSInfoID:  "rs_info_id",
		Protodata: "protodata",
	},
	RaceStateProtos: raceStateProtoColumnNames{
		ID:        "id",
		RSInfoID:  "rs_info_id",
		Protodata: "protodata",
	},
	RSInfos: rsInfoColumnNames{
		ID:            "id",
		EventID:       "event_id",
		RecordStamp:   "record_stamp",
		SessionTime:   "session_time",
		TimeOfDay:     "time_of_day",
		AirTemp:       "air_temp",
		TrackTemp:     "track_temp",
		TrackWetness:  "track_wetness",
		Precipitation: "precipitation",
		SessionNum:    "session_num",
	},
	SchemaMigrations: schemaMigrationColumnNames{
		Version: "version",
		Dirty:   "dirty",
	},
	SpeedmapProtos: speedmapProtoColumnNames{
		ID:        "id",
		RSInfoID:  "rs_info_id",
		Protodata: "protodata",
	},
	Tenants: tenantColumnNames{
		ID:         "id",
		ExternalID: "external_id",
		Name:       "name",
		APIKey:     "api_key",
		Active:     "active",
	},
	Tracks: trackColumnNames{
		ID:            "id",
		Name:          "name",
		ShortName:     "short_name",
		Config:        "config",
		TrackLength:   "track_length",
		Sectors:       "sectors",
		PitSpeed:      "pit_speed",
		PitEntry:      "pit_entry",
		PitExit:       "pit_exit",
		PitLaneLength: "pit_lane_length",
	},
}

var (
	SelectWhere     = Where[*dialect.SelectQuery]()
	UpdateWhere     = Where[*dialect.UpdateQuery]()
	DeleteWhere     = Where[*dialect.DeleteQuery]()
	OnConflictWhere = Where[*clause.ConflictClause]() // Used in ON CONFLICT DO UPDATE
)

func Where[Q psql.Filterable]() struct {
	AnalysisProtos   analysisProtoWhere[Q]
	CCars            cCarWhere[Q]
	CCarClasses      cCarClassWhere[Q]
	CCarDrivers      cCarDriverWhere[Q]
	CCarEntries      cCarEntryWhere[Q]
	CCarTeams        cCarTeamWhere[Q]
	CarStateProtos   carStateProtoWhere[Q]
	Events           eventWhere[Q]
	EventExts        eventExtWhere[Q]
	MSGStateProtos   msgStateProtoWhere[Q]
	RaceStateProtos  raceStateProtoWhere[Q]
	RSInfos          rsInfoWhere[Q]
	SchemaMigrations schemaMigrationWhere[Q]
	SpeedmapProtos   speedmapProtoWhere[Q]
	Tenants          tenantWhere[Q]
	Tracks           trackWhere[Q]
} {
	return struct {
		AnalysisProtos   analysisProtoWhere[Q]
		CCars            cCarWhere[Q]
		CCarClasses      cCarClassWhere[Q]
		CCarDrivers      cCarDriverWhere[Q]
		CCarEntries      cCarEntryWhere[Q]
		CCarTeams        cCarTeamWhere[Q]
		CarStateProtos   carStateProtoWhere[Q]
		Events           eventWhere[Q]
		EventExts        eventExtWhere[Q]
		MSGStateProtos   msgStateProtoWhere[Q]
		RaceStateProtos  raceStateProtoWhere[Q]
		RSInfos          rsInfoWhere[Q]
		SchemaMigrations schemaMigrationWhere[Q]
		SpeedmapProtos   speedmapProtoWhere[Q]
		Tenants          tenantWhere[Q]
		Tracks           trackWhere[Q]
	}{
		AnalysisProtos:   buildAnalysisProtoWhere[Q](AnalysisProtoColumns),
		CCars:            buildCCarWhere[Q](CCarColumns),
		CCarClasses:      buildCCarClassWhere[Q](CCarClassColumns),
		CCarDrivers:      buildCCarDriverWhere[Q](CCarDriverColumns),
		CCarEntries:      buildCCarEntryWhere[Q](CCarEntryColumns),
		CCarTeams:        buildCCarTeamWhere[Q](CCarTeamColumns),
		CarStateProtos:   buildCarStateProtoWhere[Q](CarStateProtoColumns),
		Events:           buildEventWhere[Q](EventColumns),
		EventExts:        buildEventExtWhere[Q](EventExtColumns),
		MSGStateProtos:   buildMSGStateProtoWhere[Q](MSGStateProtoColumns),
		RaceStateProtos:  buildRaceStateProtoWhere[Q](RaceStateProtoColumns),
		RSInfos:          buildRSInfoWhere[Q](RSInfoColumns),
		SchemaMigrations: buildSchemaMigrationWhere[Q](SchemaMigrationColumns),
		SpeedmapProtos:   buildSpeedmapProtoWhere[Q](SpeedmapProtoColumns),
		Tenants:          buildTenantWhere[Q](TenantColumns),
		Tracks:           buildTrackWhere[Q](TrackColumns),
	}
}

var Preload = getPreloaders()

type preloaders struct {
	AnalysisProto  analysisProtoPreloader
	CCar           cCarPreloader
	CCarClass      cCarClassPreloader
	CCarDriver     cCarDriverPreloader
	CCarEntry      cCarEntryPreloader
	CCarTeam       cCarTeamPreloader
	CarStateProto  carStateProtoPreloader
	Event          eventPreloader
	EventExt       eventExtPreloader
	MSGStateProto  msgStateProtoPreloader
	RaceStateProto raceStateProtoPreloader
	RSInfo         rsInfoPreloader
	SpeedmapProto  speedmapProtoPreloader
	Tenant         tenantPreloader
	Track          trackPreloader
}

func getPreloaders() preloaders {
	return preloaders{
		AnalysisProto:  buildAnalysisProtoPreloader(),
		CCar:           buildCCarPreloader(),
		CCarClass:      buildCCarClassPreloader(),
		CCarDriver:     buildCCarDriverPreloader(),
		CCarEntry:      buildCCarEntryPreloader(),
		CCarTeam:       buildCCarTeamPreloader(),
		CarStateProto:  buildCarStateProtoPreloader(),
		Event:          buildEventPreloader(),
		EventExt:       buildEventExtPreloader(),
		MSGStateProto:  buildMSGStateProtoPreloader(),
		RaceStateProto: buildRaceStateProtoPreloader(),
		RSInfo:         buildRSInfoPreloader(),
		SpeedmapProto:  buildSpeedmapProtoPreloader(),
		Tenant:         buildTenantPreloader(),
		Track:          buildTrackPreloader(),
	}
}

var (
	SelectThenLoad = getThenLoaders[*dialect.SelectQuery]()
	InsertThenLoad = getThenLoaders[*dialect.InsertQuery]()
	UpdateThenLoad = getThenLoaders[*dialect.UpdateQuery]()
)

type thenLoaders[Q orm.Loadable] struct {
	AnalysisProto  analysisProtoThenLoader[Q]
	CCar           cCarThenLoader[Q]
	CCarClass      cCarClassThenLoader[Q]
	CCarDriver     cCarDriverThenLoader[Q]
	CCarEntry      cCarEntryThenLoader[Q]
	CCarTeam       cCarTeamThenLoader[Q]
	CarStateProto  carStateProtoThenLoader[Q]
	Event          eventThenLoader[Q]
	EventExt       eventExtThenLoader[Q]
	MSGStateProto  msgStateProtoThenLoader[Q]
	RaceStateProto raceStateProtoThenLoader[Q]
	RSInfo         rsInfoThenLoader[Q]
	SpeedmapProto  speedmapProtoThenLoader[Q]
	Tenant         tenantThenLoader[Q]
	Track          trackThenLoader[Q]
}

func getThenLoaders[Q orm.Loadable]() thenLoaders[Q] {
	return thenLoaders[Q]{
		AnalysisProto:  buildAnalysisProtoThenLoader[Q](),
		CCar:           buildCCarThenLoader[Q](),
		CCarClass:      buildCCarClassThenLoader[Q](),
		CCarDriver:     buildCCarDriverThenLoader[Q](),
		CCarEntry:      buildCCarEntryThenLoader[Q](),
		CCarTeam:       buildCCarTeamThenLoader[Q](),
		CarStateProto:  buildCarStateProtoThenLoader[Q](),
		Event:          buildEventThenLoader[Q](),
		EventExt:       buildEventExtThenLoader[Q](),
		MSGStateProto:  buildMSGStateProtoThenLoader[Q](),
		RaceStateProto: buildRaceStateProtoThenLoader[Q](),
		RSInfo:         buildRSInfoThenLoader[Q](),
		SpeedmapProto:  buildSpeedmapProtoThenLoader[Q](),
		Tenant:         buildTenantThenLoader[Q](),
		Track:          buildTrackThenLoader[Q](),
	}
}

func thenLoadBuilder[Q orm.Loadable, T any](name string, f func(context.Context, bob.Executor, T, ...bob.Mod[*dialect.SelectQuery]) error) func(...bob.Mod[*dialect.SelectQuery]) orm.Loader[Q] {
	return func(queryMods ...bob.Mod[*dialect.SelectQuery]) orm.Loader[Q] {
		return func(ctx context.Context, exec bob.Executor, retrieved any) error {
			loader, isLoader := retrieved.(T)
			if !isLoader {
				return fmt.Errorf("object %T cannot load %q", retrieved, name)
			}

			err := f(ctx, exec, loader, queryMods...)

			// Don't cause an issue due to missing relationships
			if errors.Is(err, sql.ErrNoRows) {
				return nil
			}

			return err
		}
	}
}

var (
	SelectJoins = getJoins[*dialect.SelectQuery]()
	UpdateJoins = getJoins[*dialect.UpdateQuery]()
	DeleteJoins = getJoins[*dialect.DeleteQuery]()
)

type joinSet[Q interface{ aliasedAs(string) Q }] struct {
	InnerJoin Q
	LeftJoin  Q
	RightJoin Q
}

func (j joinSet[Q]) AliasedAs(alias string) joinSet[Q] {
	return joinSet[Q]{
		InnerJoin: j.InnerJoin.aliasedAs(alias),
		LeftJoin:  j.LeftJoin.aliasedAs(alias),
		RightJoin: j.RightJoin.aliasedAs(alias),
	}
}

type joins[Q dialect.Joinable] struct {
	AnalysisProtos  joinSet[analysisProtoJoins[Q]]
	CCars           joinSet[cCarJoins[Q]]
	CCarClasses     joinSet[cCarClassJoins[Q]]
	CCarDrivers     joinSet[cCarDriverJoins[Q]]
	CCarEntries     joinSet[cCarEntryJoins[Q]]
	CCarTeams       joinSet[cCarTeamJoins[Q]]
	CarStateProtos  joinSet[carStateProtoJoins[Q]]
	Events          joinSet[eventJoins[Q]]
	EventExts       joinSet[eventExtJoins[Q]]
	MSGStateProtos  joinSet[msgStateProtoJoins[Q]]
	RaceStateProtos joinSet[raceStateProtoJoins[Q]]
	RSInfos         joinSet[rsInfoJoins[Q]]
	SpeedmapProtos  joinSet[speedmapProtoJoins[Q]]
	Tenants         joinSet[tenantJoins[Q]]
	Tracks          joinSet[trackJoins[Q]]
}

func buildJoinSet[Q interface{ aliasedAs(string) Q }, C any, F func(C, string) Q](c C, f F) joinSet[Q] {
	return joinSet[Q]{
		InnerJoin: f(c, clause.InnerJoin),
		LeftJoin:  f(c, clause.LeftJoin),
		RightJoin: f(c, clause.RightJoin),
	}
}

func getJoins[Q dialect.Joinable]() joins[Q] {
	return joins[Q]{
		AnalysisProtos:  buildJoinSet[analysisProtoJoins[Q]](AnalysisProtoColumns, buildAnalysisProtoJoins),
		CCars:           buildJoinSet[cCarJoins[Q]](CCarColumns, buildCCarJoins),
		CCarClasses:     buildJoinSet[cCarClassJoins[Q]](CCarClassColumns, buildCCarClassJoins),
		CCarDrivers:     buildJoinSet[cCarDriverJoins[Q]](CCarDriverColumns, buildCCarDriverJoins),
		CCarEntries:     buildJoinSet[cCarEntryJoins[Q]](CCarEntryColumns, buildCCarEntryJoins),
		CCarTeams:       buildJoinSet[cCarTeamJoins[Q]](CCarTeamColumns, buildCCarTeamJoins),
		CarStateProtos:  buildJoinSet[carStateProtoJoins[Q]](CarStateProtoColumns, buildCarStateProtoJoins),
		Events:          buildJoinSet[eventJoins[Q]](EventColumns, buildEventJoins),
		EventExts:       buildJoinSet[eventExtJoins[Q]](EventExtColumns, buildEventExtJoins),
		MSGStateProtos:  buildJoinSet[msgStateProtoJoins[Q]](MSGStateProtoColumns, buildMSGStateProtoJoins),
		RaceStateProtos: buildJoinSet[raceStateProtoJoins[Q]](RaceStateProtoColumns, buildRaceStateProtoJoins),
		RSInfos:         buildJoinSet[rsInfoJoins[Q]](RSInfoColumns, buildRSInfoJoins),
		SpeedmapProtos:  buildJoinSet[speedmapProtoJoins[Q]](SpeedmapProtoColumns, buildSpeedmapProtoJoins),
		Tenants:         buildJoinSet[tenantJoins[Q]](TenantColumns, buildTenantJoins),
		Tracks:          buildJoinSet[trackJoins[Q]](TrackColumns, buildTrackJoins),
	}
}

type modAs[Q any, C interface{ AliasedAs(string) C }] struct {
	c C
	f func(C) bob.Mod[Q]
}

func (m modAs[Q, C]) Apply(q Q) {
	m.f(m.c).Apply(q)
}

func (m modAs[Q, C]) AliasedAs(alias string) bob.Mod[Q] {
	m.c = m.c.AliasedAs(alias)
	return m
}

func randInt() int64 {
	out := int64(new(maphash.Hash).Sum64())

	if out < 0 {
		return -out % 10000
	}

	return out % 10000
}

// ErrUniqueConstraint captures all unique constraint errors by explicitly leaving `s` empty.
var ErrUniqueConstraint = &UniqueConstraintError{s: ""}

type UniqueConstraintError struct {
	// schema is the schema where the unique constraint is defined.
	schema string
	// table is the name of the table where the unique constraint is defined.
	table string
	// columns are the columns constituting the unique constraint.
	columns []string
	// s is a string uniquely identifying the constraint in the raw error message returned from the database.
	s string
}

func (e *UniqueConstraintError) Error() string {
	return e.s
}

func (e *UniqueConstraintError) Is(target error) bool {
	err, ok := target.(*pq.Error)
	if !ok {
		return false
	}
	return err.Code == "23505" && (e.s == "" || err.Constraint == e.s)
}
